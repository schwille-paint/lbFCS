import os
import importlib
import numpy as np
import time
import warnings
warnings.filterwarnings("ignore")

import picasso.io as _io
import picasso.postprocess as _postprocess
import picasso.render as _render

import lbfcs.picasso_wrap as pic_wrap
import lbfcs.pickprops as props
import lbfcs.pickprops_calls as props_call
import lbfcs.io as io_lbfcs

importlib.reload(pic_wrap)


def _master(path,
            box=5,
            mng=400,
            segments=500,
            oversampling=5,
            box_pick=9,
            mng_pick=400,
            pick_diameter=2,
            ignore=1,
            NoPartitions=30):
    
    try:
        conc=float(input('Please enter concentration in nM\n'))
    except:
        print('Execution aborted')
        return
    
    start_time=time.time()
    ################################################## Localize & Undrift
    print('Loading movie ...')
    #### Load raw movie
    movie, info = _io.load_movie(path)

    #### Localize
    spots,locs=pic_wrap._localize_movie(movie,box,mng)
    
    #### Save _locs
    print('Saving _locs ...')
    info_locs=info.copy()
    info_locs=info_locs+[{'Box Size':box,'Generated by':'localize_rcc.py','Min. Net Gradient': mng}]
    _io.save_locs(os.path.splitext(path)[0]+'_locs.hdf5',
                 locs,
                 info_locs,
                 )

    #### Undrift by RCC
    drift,locs_render=_postprocess.undrift(locs,
                         info,
                         segments,
                         display=False,
                         segmentation_callback=None,
                         rcc_callback=None,
                         )
    
    #### Save _locs_render.hdf5
    print('Saving _render ...')
    info_locs_render=info_locs.copy()
    info_locs_render=info_locs_render+[{'Segmentation':segments,'Generated by':'localize_rcc.py'}]
    _io.save_locs(os.path.splitext(path)[0]+'_locs_render.hdf5',
                 locs_render,
                 info_locs_render,
                 )
    
    ################################################## Define picks
    #### Render _locs_render to image with oversampling
    print('Rendering locs for pick detection ...')
    image=_render.render(locs_render,
                        info,
                        oversampling=oversampling,
                        )[1]
    

    #### Detect picks in _locs_render
    print('Pick detection ...')
    picks=pic_wrap._spots_in_image(image,mng_pick,box_pick,fit=True)
    
    #### Save _picks.yaml
    save_picks=picks.copy()
    save_picks.x=save_picks.x/oversampling # Conversion to original pixel size
    save_picks.y=save_picks.y/oversampling # Conversion to original pixel size
    pic_wrap._locs2picks(save_picks,
                         pick_diameter,
                         os.path.splitext(path)[0]+'_locs_render_autopick.yaml')
    

    #### Get locs_picked by index locs_render
    print('Indexing & sorting ...')
    centers=np.vstack([picks.x,picks.y]).transpose()/oversampling
    locs_picked=pic_wrap._get_picked(locs_render,centers,pick_diameter*0.5)
    
    #### Save _locs_render_picked.hdf5
    print('Saving _picked ...')
    info_picked=info_locs_render.copy()
    info_picked=info_picked+[{'Pick diameter':pick_diameter,'Oversampling':oversampling,'box':box_pick,'mng':mng_pick,'Generated by':'autopick.py'}]
    _io.save_locs(os.path.splitext(path)[0]+'_locs_render_picked.hdf5',
                 locs_picked.to_records(index=False),
                 info_picked,
                 )
    
    ################################################## Extract kinetic information
    #### Apply props
    print('Calculating kinetics ...')
    NoFrames=info[0]['Frames']
    if NoPartitions==1:
        print('... non-parallel')
        locs_props=props.apply_props(locs_picked,conc,NoFrames,ignore)
    elif NoPartitions>1:
        print('... in parallel')
        locs_props=props.apply_props_dask(locs_picked,conc,NoFrames,ignore,NoPartitions)
    
    #### Remove distributions
    locs_props=locs_props.drop(['trace','tau','g','tau_b_dist','tau_d_dist'],axis=1)

    print('Applying kinetic filter ...')
    locs_props=props._kin_filter(locs_props)
    
    #### Add nearest neigbour pick and distance
    print('Calculating nearest neighbour ...')
    locs_props=props_call.props_add_nn(locs_props)
    
    #### Save _locs_render_picked_props.hdf5
    print('File _props ...')
        
    ### Dictonary added content for info '.yaml' file
    info_props=info_picked.copy()
    info_props=info_props+[{'Generated by':'lbfcs.lbfcs.master','kin_filter': True,'NoPartitions':NoPartitions}]
    io_lbfcs.save_locs(os.path.splitext(path)[0]+'_locs_render_picked_props_ig%i.hdf5'%(ignore),
                    locs_props,
                    info_props,
                    mode='picasso_compatible')
    
    print('Total time: %.2f'%(time.time()-start_time))
    
    return movie,info,locs,locs_render,centers,locs_picked,locs_props,conc